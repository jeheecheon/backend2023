// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace mju {
class CSChat;
class CSChatDefaultTypeInternal;
extern CSChatDefaultTypeInternal _CSChat_default_instance_;
class CSCreateRoom;
class CSCreateRoomDefaultTypeInternal;
extern CSCreateRoomDefaultTypeInternal _CSCreateRoom_default_instance_;
class CSJoinRoom;
class CSJoinRoomDefaultTypeInternal;
extern CSJoinRoomDefaultTypeInternal _CSJoinRoom_default_instance_;
class CSLeaveRoom;
class CSLeaveRoomDefaultTypeInternal;
extern CSLeaveRoomDefaultTypeInternal _CSLeaveRoom_default_instance_;
class CSName;
class CSNameDefaultTypeInternal;
extern CSNameDefaultTypeInternal _CSName_default_instance_;
class CSRooms;
class CSRoomsDefaultTypeInternal;
extern CSRoomsDefaultTypeInternal _CSRooms_default_instance_;
class CSShutdown;
class CSShutdownDefaultTypeInternal;
extern CSShutdownDefaultTypeInternal _CSShutdown_default_instance_;
class SCChat;
class SCChatDefaultTypeInternal;
extern SCChatDefaultTypeInternal _SCChat_default_instance_;
class SCCreateRoomResult;
class SCCreateRoomResultDefaultTypeInternal;
extern SCCreateRoomResultDefaultTypeInternal _SCCreateRoomResult_default_instance_;
class SCJoinRoomResult;
class SCJoinRoomResultDefaultTypeInternal;
extern SCJoinRoomResultDefaultTypeInternal _SCJoinRoomResult_default_instance_;
class SCLeaveRoomResult;
class SCLeaveRoomResultDefaultTypeInternal;
extern SCLeaveRoomResultDefaultTypeInternal _SCLeaveRoomResult_default_instance_;
class SCNameResult;
class SCNameResultDefaultTypeInternal;
extern SCNameResultDefaultTypeInternal _SCNameResult_default_instance_;
class SCRoomsResult;
class SCRoomsResultDefaultTypeInternal;
extern SCRoomsResultDefaultTypeInternal _SCRoomsResult_default_instance_;
class SCRoomsResult_RoomInfo;
class SCRoomsResult_RoomInfoDefaultTypeInternal;
extern SCRoomsResult_RoomInfoDefaultTypeInternal _SCRoomsResult_RoomInfo_default_instance_;
class SCSystemMessage;
class SCSystemMessageDefaultTypeInternal;
extern SCSystemMessageDefaultTypeInternal _SCSystemMessage_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
}  // namespace mju
PROTOBUF_NAMESPACE_OPEN
template<> ::mju::CSChat* Arena::CreateMaybeMessage<::mju::CSChat>(Arena*);
template<> ::mju::CSCreateRoom* Arena::CreateMaybeMessage<::mju::CSCreateRoom>(Arena*);
template<> ::mju::CSJoinRoom* Arena::CreateMaybeMessage<::mju::CSJoinRoom>(Arena*);
template<> ::mju::CSLeaveRoom* Arena::CreateMaybeMessage<::mju::CSLeaveRoom>(Arena*);
template<> ::mju::CSName* Arena::CreateMaybeMessage<::mju::CSName>(Arena*);
template<> ::mju::CSRooms* Arena::CreateMaybeMessage<::mju::CSRooms>(Arena*);
template<> ::mju::CSShutdown* Arena::CreateMaybeMessage<::mju::CSShutdown>(Arena*);
template<> ::mju::SCChat* Arena::CreateMaybeMessage<::mju::SCChat>(Arena*);
template<> ::mju::SCCreateRoomResult* Arena::CreateMaybeMessage<::mju::SCCreateRoomResult>(Arena*);
template<> ::mju::SCJoinRoomResult* Arena::CreateMaybeMessage<::mju::SCJoinRoomResult>(Arena*);
template<> ::mju::SCLeaveRoomResult* Arena::CreateMaybeMessage<::mju::SCLeaveRoomResult>(Arena*);
template<> ::mju::SCNameResult* Arena::CreateMaybeMessage<::mju::SCNameResult>(Arena*);
template<> ::mju::SCRoomsResult* Arena::CreateMaybeMessage<::mju::SCRoomsResult>(Arena*);
template<> ::mju::SCRoomsResult_RoomInfo* Arena::CreateMaybeMessage<::mju::SCRoomsResult_RoomInfo>(Arena*);
template<> ::mju::SCSystemMessage* Arena::CreateMaybeMessage<::mju::SCSystemMessage>(Arena*);
template<> ::mju::Type* Arena::CreateMaybeMessage<::mju::Type>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mju {

enum Type_MessageType : int {
  Type_MessageType_CS_NAME = 0,
  Type_MessageType_CS_ROOMS = 1,
  Type_MessageType_CS_CREATE_ROOM = 2,
  Type_MessageType_CS_JOIN_ROOM = 3,
  Type_MessageType_CS_LEAVE_ROOM = 4,
  Type_MessageType_CS_CHAT = 5,
  Type_MessageType_CS_SHUTDOWN = 6,
  Type_MessageType_SC_ROOMS_RESULT = 7,
  Type_MessageType_SC_CHAT = 8,
  Type_MessageType_SC_SYSTEM_MESSAGE = 9
};
bool Type_MessageType_IsValid(int value);
constexpr Type_MessageType Type_MessageType_MessageType_MIN = Type_MessageType_CS_NAME;
constexpr Type_MessageType Type_MessageType_MessageType_MAX = Type_MessageType_SC_SYSTEM_MESSAGE;
constexpr int Type_MessageType_MessageType_ARRAYSIZE = Type_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_MessageType_descriptor();
template<typename T>
inline const std::string& Type_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_MessageType_descriptor(), enum_t_value);
}
inline bool Type_MessageType_Parse(
    const std::string& name, Type_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type_MessageType>(
    Type_MessageType_descriptor(), name, value);
}
// ===================================================================

class Type PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.Type) */ {
 public:
  inline Type() : Type(nullptr) {};
  virtual ~Type();

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(nullptr);
  }

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Type_MessageType MessageType;
  static constexpr MessageType CS_NAME =
    Type_MessageType_CS_NAME;
  static constexpr MessageType CS_ROOMS =
    Type_MessageType_CS_ROOMS;
  static constexpr MessageType CS_CREATE_ROOM =
    Type_MessageType_CS_CREATE_ROOM;
  static constexpr MessageType CS_JOIN_ROOM =
    Type_MessageType_CS_JOIN_ROOM;
  static constexpr MessageType CS_LEAVE_ROOM =
    Type_MessageType_CS_LEAVE_ROOM;
  static constexpr MessageType CS_CHAT =
    Type_MessageType_CS_CHAT;
  static constexpr MessageType CS_SHUTDOWN =
    Type_MessageType_CS_SHUTDOWN;
  static constexpr MessageType SC_ROOMS_RESULT =
    Type_MessageType_SC_ROOMS_RESULT;
  static constexpr MessageType SC_CHAT =
    Type_MessageType_SC_CHAT;
  static constexpr MessageType SC_SYSTEM_MESSAGE =
    Type_MessageType_SC_SYSTEM_MESSAGE;
  static inline bool MessageType_IsValid(int value) {
    return Type_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    Type_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    Type_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    Type_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return Type_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return Type_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(const std::string& name,
      MessageType* value) {
    return Type_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // required .mju.Type.MessageType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::mju::Type_MessageType type() const;
  void set_type(::mju::Type_MessageType value);
  private:
  ::mju::Type_MessageType _internal_type() const;
  void _internal_set_type(::mju::Type_MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:mju.Type)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSName PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSName) */ {
 public:
  inline CSName() : CSName(nullptr) {};
  virtual ~CSName();

  CSName(const CSName& from);
  CSName(CSName&& from) noexcept
    : CSName() {
    *this = ::std::move(from);
  }

  inline CSName& operator=(const CSName& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSName& operator=(CSName&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CSName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSName* internal_default_instance() {
    return reinterpret_cast<const CSName*>(
               &_CSName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CSName& a, CSName& b) {
    a.Swap(&b);
  }
  inline void Swap(CSName* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSName* New() const final {
    return CreateMaybeMessage<CSName>(nullptr);
  }

  CSName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSName>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CSName& from);
  void MergeFrom(const CSName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSName";
  }
  protected:
  explicit CSName(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:mju.CSName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSRooms PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSRooms) */ {
 public:
  inline CSRooms() : CSRooms(nullptr) {};
  virtual ~CSRooms();

  CSRooms(const CSRooms& from);
  CSRooms(CSRooms&& from) noexcept
    : CSRooms() {
    *this = ::std::move(from);
  }

  inline CSRooms& operator=(const CSRooms& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSRooms& operator=(CSRooms&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CSRooms& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSRooms* internal_default_instance() {
    return reinterpret_cast<const CSRooms*>(
               &_CSRooms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CSRooms& a, CSRooms& b) {
    a.Swap(&b);
  }
  inline void Swap(CSRooms* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSRooms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSRooms* New() const final {
    return CreateMaybeMessage<CSRooms>(nullptr);
  }

  CSRooms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSRooms>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CSRooms& from);
  void MergeFrom(const CSRooms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSRooms* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSRooms";
  }
  protected:
  explicit CSRooms(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mju.CSRooms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSCreateRoom PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSCreateRoom) */ {
 public:
  inline CSCreateRoom() : CSCreateRoom(nullptr) {};
  virtual ~CSCreateRoom();

  CSCreateRoom(const CSCreateRoom& from);
  CSCreateRoom(CSCreateRoom&& from) noexcept
    : CSCreateRoom() {
    *this = ::std::move(from);
  }

  inline CSCreateRoom& operator=(const CSCreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSCreateRoom& operator=(CSCreateRoom&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CSCreateRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSCreateRoom* internal_default_instance() {
    return reinterpret_cast<const CSCreateRoom*>(
               &_CSCreateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CSCreateRoom& a, CSCreateRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CSCreateRoom* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSCreateRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSCreateRoom* New() const final {
    return CreateMaybeMessage<CSCreateRoom>(nullptr);
  }

  CSCreateRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSCreateRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CSCreateRoom& from);
  void MergeFrom(const CSCreateRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSCreateRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSCreateRoom";
  }
  protected:
  explicit CSCreateRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_title();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_title(
      std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:mju.CSCreateRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSJoinRoom PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSJoinRoom) */ {
 public:
  inline CSJoinRoom() : CSJoinRoom(nullptr) {};
  virtual ~CSJoinRoom();

  CSJoinRoom(const CSJoinRoom& from);
  CSJoinRoom(CSJoinRoom&& from) noexcept
    : CSJoinRoom() {
    *this = ::std::move(from);
  }

  inline CSJoinRoom& operator=(const CSJoinRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSJoinRoom& operator=(CSJoinRoom&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CSJoinRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSJoinRoom* internal_default_instance() {
    return reinterpret_cast<const CSJoinRoom*>(
               &_CSJoinRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CSJoinRoom& a, CSJoinRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CSJoinRoom* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSJoinRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSJoinRoom* New() const final {
    return CreateMaybeMessage<CSJoinRoom>(nullptr);
  }

  CSJoinRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSJoinRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CSJoinRoom& from);
  void MergeFrom(const CSJoinRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSJoinRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSJoinRoom";
  }
  protected:
  explicit CSJoinRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // required int32 roomId = 1;
  bool has_roomid() const;
  private:
  bool _internal_has_roomid() const;
  public:
  void clear_roomid();
  ::PROTOBUF_NAMESPACE_ID::int32 roomid() const;
  void set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roomid() const;
  void _internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mju.CSJoinRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 roomid_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSLeaveRoom PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSLeaveRoom) */ {
 public:
  inline CSLeaveRoom() : CSLeaveRoom(nullptr) {};
  virtual ~CSLeaveRoom();

  CSLeaveRoom(const CSLeaveRoom& from);
  CSLeaveRoom(CSLeaveRoom&& from) noexcept
    : CSLeaveRoom() {
    *this = ::std::move(from);
  }

  inline CSLeaveRoom& operator=(const CSLeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSLeaveRoom& operator=(CSLeaveRoom&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CSLeaveRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSLeaveRoom* internal_default_instance() {
    return reinterpret_cast<const CSLeaveRoom*>(
               &_CSLeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CSLeaveRoom& a, CSLeaveRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(CSLeaveRoom* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSLeaveRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSLeaveRoom* New() const final {
    return CreateMaybeMessage<CSLeaveRoom>(nullptr);
  }

  CSLeaveRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSLeaveRoom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CSLeaveRoom& from);
  void MergeFrom(const CSLeaveRoom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSLeaveRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSLeaveRoom";
  }
  protected:
  explicit CSLeaveRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mju.CSLeaveRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSChat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSChat) */ {
 public:
  inline CSChat() : CSChat(nullptr) {};
  virtual ~CSChat();

  CSChat(const CSChat& from);
  CSChat(CSChat&& from) noexcept
    : CSChat() {
    *this = ::std::move(from);
  }

  inline CSChat& operator=(const CSChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSChat& operator=(CSChat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CSChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSChat* internal_default_instance() {
    return reinterpret_cast<const CSChat*>(
               &_CSChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CSChat& a, CSChat& b) {
    a.Swap(&b);
  }
  inline void Swap(CSChat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSChat* New() const final {
    return CreateMaybeMessage<CSChat>(nullptr);
  }

  CSChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSChat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CSChat& from);
  void MergeFrom(const CSChat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSChat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSChat";
  }
  protected:
  explicit CSChat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // required string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_text(
      std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mju.CSChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class CSShutdown PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.CSShutdown) */ {
 public:
  inline CSShutdown() : CSShutdown(nullptr) {};
  virtual ~CSShutdown();

  CSShutdown(const CSShutdown& from);
  CSShutdown(CSShutdown&& from) noexcept
    : CSShutdown() {
    *this = ::std::move(from);
  }

  inline CSShutdown& operator=(const CSShutdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSShutdown& operator=(CSShutdown&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CSShutdown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CSShutdown* internal_default_instance() {
    return reinterpret_cast<const CSShutdown*>(
               &_CSShutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CSShutdown& a, CSShutdown& b) {
    a.Swap(&b);
  }
  inline void Swap(CSShutdown* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSShutdown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CSShutdown* New() const final {
    return CreateMaybeMessage<CSShutdown>(nullptr);
  }

  CSShutdown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CSShutdown>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CSShutdown& from);
  void MergeFrom(const CSShutdown& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSShutdown* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.CSShutdown";
  }
  protected:
  explicit CSShutdown(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mju.CSShutdown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCNameResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCNameResult) */ {
 public:
  inline SCNameResult() : SCNameResult(nullptr) {};
  virtual ~SCNameResult();

  SCNameResult(const SCNameResult& from);
  SCNameResult(SCNameResult&& from) noexcept
    : SCNameResult() {
    *this = ::std::move(from);
  }

  inline SCNameResult& operator=(const SCNameResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCNameResult& operator=(SCNameResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCNameResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCNameResult* internal_default_instance() {
    return reinterpret_cast<const SCNameResult*>(
               &_SCNameResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SCNameResult& a, SCNameResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCNameResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCNameResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCNameResult* New() const final {
    return CreateMaybeMessage<SCNameResult>(nullptr);
  }

  SCNameResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCNameResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCNameResult& from);
  void MergeFrom(const SCNameResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCNameResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCNameResult";
  }
  protected:
  explicit SCNameResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCNameResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCRoomsResult_RoomInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCRoomsResult.RoomInfo) */ {
 public:
  inline SCRoomsResult_RoomInfo() : SCRoomsResult_RoomInfo(nullptr) {};
  virtual ~SCRoomsResult_RoomInfo();

  SCRoomsResult_RoomInfo(const SCRoomsResult_RoomInfo& from);
  SCRoomsResult_RoomInfo(SCRoomsResult_RoomInfo&& from) noexcept
    : SCRoomsResult_RoomInfo() {
    *this = ::std::move(from);
  }

  inline SCRoomsResult_RoomInfo& operator=(const SCRoomsResult_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCRoomsResult_RoomInfo& operator=(SCRoomsResult_RoomInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCRoomsResult_RoomInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCRoomsResult_RoomInfo* internal_default_instance() {
    return reinterpret_cast<const SCRoomsResult_RoomInfo*>(
               &_SCRoomsResult_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SCRoomsResult_RoomInfo& a, SCRoomsResult_RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SCRoomsResult_RoomInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCRoomsResult_RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCRoomsResult_RoomInfo* New() const final {
    return CreateMaybeMessage<SCRoomsResult_RoomInfo>(nullptr);
  }

  SCRoomsResult_RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCRoomsResult_RoomInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCRoomsResult_RoomInfo& from);
  void MergeFrom(const SCRoomsResult_RoomInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCRoomsResult_RoomInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCRoomsResult.RoomInfo";
  }
  protected:
  explicit SCRoomsResult_RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 3,
    kTitleFieldNumber = 2,
    kRoomIdFieldNumber = 1,
  };
  // repeated string members = 3;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  const std::string& members(int index) const;
  std::string* mutable_members(int index);
  void set_members(int index, const std::string& value);
  void set_members(int index, std::string&& value);
  void set_members(int index, const char* value);
  void set_members(int index, const char* value, size_t size);
  std::string* add_members();
  void add_members(const std::string& value);
  void add_members(std::string&& value);
  void add_members(const char* value);
  void add_members(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_members();
  private:
  const std::string& _internal_members(int index) const;
  std::string* _internal_add_members();
  public:

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_title();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_title(
      std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // required int32 roomId = 1;
  bool has_roomid() const;
  private:
  bool _internal_has_roomid() const;
  public:
  void clear_roomid();
  ::PROTOBUF_NAMESPACE_ID::int32 roomid() const;
  void set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roomid() const;
  void _internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mju.SCRoomsResult.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> members_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::int32 roomid_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCRoomsResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCRoomsResult) */ {
 public:
  inline SCRoomsResult() : SCRoomsResult(nullptr) {};
  virtual ~SCRoomsResult();

  SCRoomsResult(const SCRoomsResult& from);
  SCRoomsResult(SCRoomsResult&& from) noexcept
    : SCRoomsResult() {
    *this = ::std::move(from);
  }

  inline SCRoomsResult& operator=(const SCRoomsResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCRoomsResult& operator=(SCRoomsResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCRoomsResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCRoomsResult* internal_default_instance() {
    return reinterpret_cast<const SCRoomsResult*>(
               &_SCRoomsResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SCRoomsResult& a, SCRoomsResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCRoomsResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCRoomsResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCRoomsResult* New() const final {
    return CreateMaybeMessage<SCRoomsResult>(nullptr);
  }

  SCRoomsResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCRoomsResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCRoomsResult& from);
  void MergeFrom(const SCRoomsResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCRoomsResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCRoomsResult";
  }
  protected:
  explicit SCRoomsResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SCRoomsResult_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .mju.SCRoomsResult.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::mju::SCRoomsResult_RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >*
      mutable_rooms();
  private:
  const ::mju::SCRoomsResult_RoomInfo& _internal_rooms(int index) const;
  ::mju::SCRoomsResult_RoomInfo* _internal_add_rooms();
  public:
  const ::mju::SCRoomsResult_RoomInfo& rooms(int index) const;
  ::mju::SCRoomsResult_RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:mju.SCRoomsResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo > rooms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCCreateRoomResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCCreateRoomResult) */ {
 public:
  inline SCCreateRoomResult() : SCCreateRoomResult(nullptr) {};
  virtual ~SCCreateRoomResult();

  SCCreateRoomResult(const SCCreateRoomResult& from);
  SCCreateRoomResult(SCCreateRoomResult&& from) noexcept
    : SCCreateRoomResult() {
    *this = ::std::move(from);
  }

  inline SCCreateRoomResult& operator=(const SCCreateRoomResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCCreateRoomResult& operator=(SCCreateRoomResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCCreateRoomResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCCreateRoomResult* internal_default_instance() {
    return reinterpret_cast<const SCCreateRoomResult*>(
               &_SCCreateRoomResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SCCreateRoomResult& a, SCCreateRoomResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCCreateRoomResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCCreateRoomResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCCreateRoomResult* New() const final {
    return CreateMaybeMessage<SCCreateRoomResult>(nullptr);
  }

  SCCreateRoomResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCCreateRoomResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCCreateRoomResult& from);
  void MergeFrom(const SCCreateRoomResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCCreateRoomResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCCreateRoomResult";
  }
  protected:
  explicit SCCreateRoomResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCCreateRoomResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCJoinRoomResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCJoinRoomResult) */ {
 public:
  inline SCJoinRoomResult() : SCJoinRoomResult(nullptr) {};
  virtual ~SCJoinRoomResult();

  SCJoinRoomResult(const SCJoinRoomResult& from);
  SCJoinRoomResult(SCJoinRoomResult&& from) noexcept
    : SCJoinRoomResult() {
    *this = ::std::move(from);
  }

  inline SCJoinRoomResult& operator=(const SCJoinRoomResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCJoinRoomResult& operator=(SCJoinRoomResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCJoinRoomResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCJoinRoomResult* internal_default_instance() {
    return reinterpret_cast<const SCJoinRoomResult*>(
               &_SCJoinRoomResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SCJoinRoomResult& a, SCJoinRoomResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCJoinRoomResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCJoinRoomResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCJoinRoomResult* New() const final {
    return CreateMaybeMessage<SCJoinRoomResult>(nullptr);
  }

  SCJoinRoomResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCJoinRoomResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCJoinRoomResult& from);
  void MergeFrom(const SCJoinRoomResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCJoinRoomResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCJoinRoomResult";
  }
  protected:
  explicit SCJoinRoomResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCJoinRoomResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCLeaveRoomResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCLeaveRoomResult) */ {
 public:
  inline SCLeaveRoomResult() : SCLeaveRoomResult(nullptr) {};
  virtual ~SCLeaveRoomResult();

  SCLeaveRoomResult(const SCLeaveRoomResult& from);
  SCLeaveRoomResult(SCLeaveRoomResult&& from) noexcept
    : SCLeaveRoomResult() {
    *this = ::std::move(from);
  }

  inline SCLeaveRoomResult& operator=(const SCLeaveRoomResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCLeaveRoomResult& operator=(SCLeaveRoomResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCLeaveRoomResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCLeaveRoomResult* internal_default_instance() {
    return reinterpret_cast<const SCLeaveRoomResult*>(
               &_SCLeaveRoomResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SCLeaveRoomResult& a, SCLeaveRoomResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SCLeaveRoomResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCLeaveRoomResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCLeaveRoomResult* New() const final {
    return CreateMaybeMessage<SCLeaveRoomResult>(nullptr);
  }

  SCLeaveRoomResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCLeaveRoomResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCLeaveRoomResult& from);
  void MergeFrom(const SCLeaveRoomResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCLeaveRoomResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCLeaveRoomResult";
  }
  protected:
  explicit SCLeaveRoomResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // optional string error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCLeaveRoomResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCChat PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCChat) */ {
 public:
  inline SCChat() : SCChat(nullptr) {};
  virtual ~SCChat();

  SCChat(const SCChat& from);
  SCChat(SCChat&& from) noexcept
    : SCChat() {
    *this = ::std::move(from);
  }

  inline SCChat& operator=(const SCChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCChat& operator=(SCChat&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCChat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCChat* internal_default_instance() {
    return reinterpret_cast<const SCChat*>(
               &_SCChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SCChat& a, SCChat& b) {
    a.Swap(&b);
  }
  inline void Swap(SCChat* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCChat* New() const final {
    return CreateMaybeMessage<SCChat>(nullptr);
  }

  SCChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCChat>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCChat& from);
  void MergeFrom(const SCChat& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCChat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCChat";
  }
  protected:
  explicit SCChat(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemberFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // required string member = 1;
  bool has_member() const;
  private:
  bool _internal_has_member() const;
  public:
  void clear_member();
  const std::string& member() const;
  void set_member(const std::string& value);
  void set_member(std::string&& value);
  void set_member(const char* value);
  void set_member(const char* value, size_t size);
  std::string* mutable_member();
  std::string* release_member();
  void set_allocated_member(std::string* member);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_member();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_member(
      std::string* member);
  private:
  const std::string& _internal_member() const;
  void _internal_set_member(const std::string& value);
  std::string* _internal_mutable_member();
  public:

  // required string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_text(
      std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCChat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class SCSystemMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mju.SCSystemMessage) */ {
 public:
  inline SCSystemMessage() : SCSystemMessage(nullptr) {};
  virtual ~SCSystemMessage();

  SCSystemMessage(const SCSystemMessage& from);
  SCSystemMessage(SCSystemMessage&& from) noexcept
    : SCSystemMessage() {
    *this = ::std::move(from);
  }

  inline SCSystemMessage& operator=(const SCSystemMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCSystemMessage& operator=(SCSystemMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SCSystemMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SCSystemMessage* internal_default_instance() {
    return reinterpret_cast<const SCSystemMessage*>(
               &_SCSystemMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SCSystemMessage& a, SCSystemMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SCSystemMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCSystemMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SCSystemMessage* New() const final {
    return CreateMaybeMessage<SCSystemMessage>(nullptr);
  }

  SCSystemMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SCSystemMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SCSystemMessage& from);
  void MergeFrom(const SCSystemMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SCSystemMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mju.SCSystemMessage";
  }
  protected:
  explicit SCSystemMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // required string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_text(
      std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:mju.SCSystemMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Type

// required .mju.Type.MessageType type = 1;
inline bool Type::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Type::has_type() const {
  return _internal_has_type();
}
inline void Type::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::mju::Type_MessageType Type::_internal_type() const {
  return static_cast< ::mju::Type_MessageType >(type_);
}
inline ::mju::Type_MessageType Type::type() const {
  // @@protoc_insertion_point(field_get:mju.Type.type)
  return _internal_type();
}
inline void Type::_internal_set_type(::mju::Type_MessageType value) {
  assert(::mju::Type_MessageType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void Type::set_type(::mju::Type_MessageType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mju.Type.type)
}

// -------------------------------------------------------------------

// CSName

// required string name = 1;
inline bool CSName::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSName::has_name() const {
  return _internal_has_name();
}
inline void CSName::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSName::name() const {
  // @@protoc_insertion_point(field_get:mju.CSName.name)
  return _internal_name();
}
inline void CSName::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mju.CSName.name)
}
inline std::string* CSName::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mju.CSName.name)
  return _internal_mutable_name();
}
inline const std::string& CSName::_internal_name() const {
  return name_.Get();
}
inline void CSName::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CSName::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.CSName.name)
}
inline void CSName::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.CSName.name)
}
inline void CSName::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.CSName.name)
}
inline std::string* CSName::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CSName::release_name() {
  // @@protoc_insertion_point(field_release:mju.CSName.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CSName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.CSName.name)
}
inline std::string* CSName::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.CSName.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CSName::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.CSName.name)
}

// -------------------------------------------------------------------

// CSRooms

// -------------------------------------------------------------------

// CSCreateRoom

// optional string title = 1;
inline bool CSCreateRoom::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSCreateRoom::has_title() const {
  return _internal_has_title();
}
inline void CSCreateRoom::clear_title() {
  title_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSCreateRoom::title() const {
  // @@protoc_insertion_point(field_get:mju.CSCreateRoom.title)
  return _internal_title();
}
inline void CSCreateRoom::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:mju.CSCreateRoom.title)
}
inline std::string* CSCreateRoom::mutable_title() {
  // @@protoc_insertion_point(field_mutable:mju.CSCreateRoom.title)
  return _internal_mutable_title();
}
inline const std::string& CSCreateRoom::_internal_title() const {
  return title_.Get();
}
inline void CSCreateRoom::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CSCreateRoom::set_title(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.CSCreateRoom.title)
}
inline void CSCreateRoom::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.CSCreateRoom.title)
}
inline void CSCreateRoom::set_title(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.CSCreateRoom.title)
}
inline std::string* CSCreateRoom::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CSCreateRoom::release_title() {
  // @@protoc_insertion_point(field_release:mju.CSCreateRoom.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CSCreateRoom::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.CSCreateRoom.title)
}
inline std::string* CSCreateRoom::unsafe_arena_release_title() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.CSCreateRoom.title)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return title_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CSCreateRoom::unsafe_arena_set_allocated_title(
    std::string* title) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      title, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.CSCreateRoom.title)
}

// -------------------------------------------------------------------

// CSJoinRoom

// required int32 roomId = 1;
inline bool CSJoinRoom::_internal_has_roomid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSJoinRoom::has_roomid() const {
  return _internal_has_roomid();
}
inline void CSJoinRoom::clear_roomid() {
  roomid_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSJoinRoom::_internal_roomid() const {
  return roomid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CSJoinRoom::roomid() const {
  // @@protoc_insertion_point(field_get:mju.CSJoinRoom.roomId)
  return _internal_roomid();
}
inline void CSJoinRoom::_internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  roomid_ = value;
}
inline void CSJoinRoom::set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:mju.CSJoinRoom.roomId)
}

// -------------------------------------------------------------------

// CSLeaveRoom

// -------------------------------------------------------------------

// CSChat

// required string text = 1;
inline bool CSChat::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSChat::has_text() const {
  return _internal_has_text();
}
inline void CSChat::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSChat::text() const {
  // @@protoc_insertion_point(field_get:mju.CSChat.text)
  return _internal_text();
}
inline void CSChat::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:mju.CSChat.text)
}
inline std::string* CSChat::mutable_text() {
  // @@protoc_insertion_point(field_mutable:mju.CSChat.text)
  return _internal_mutable_text();
}
inline const std::string& CSChat::_internal_text() const {
  return text_.Get();
}
inline void CSChat::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CSChat::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.CSChat.text)
}
inline void CSChat::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.CSChat.text)
}
inline void CSChat::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.CSChat.text)
}
inline std::string* CSChat::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CSChat::release_text() {
  // @@protoc_insertion_point(field_release:mju.CSChat.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CSChat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.CSChat.text)
}
inline std::string* CSChat::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.CSChat.text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CSChat::unsafe_arena_set_allocated_text(
    std::string* text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.CSChat.text)
}

// -------------------------------------------------------------------

// CSShutdown

// -------------------------------------------------------------------

// SCNameResult

// optional string error = 1;
inline bool SCNameResult::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCNameResult::has_error() const {
  return _internal_has_error();
}
inline void SCNameResult::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCNameResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCNameResult.error)
  return _internal_error();
}
inline void SCNameResult::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:mju.SCNameResult.error)
}
inline std::string* SCNameResult::mutable_error() {
  // @@protoc_insertion_point(field_mutable:mju.SCNameResult.error)
  return _internal_mutable_error();
}
inline const std::string& SCNameResult::_internal_error() const {
  return error_.Get();
}
inline void SCNameResult::_internal_set_error(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCNameResult::set_error(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCNameResult.error)
}
inline void SCNameResult::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCNameResult.error)
}
inline void SCNameResult::set_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCNameResult.error)
}
inline std::string* SCNameResult::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCNameResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCNameResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCNameResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCNameResult.error)
}
inline std::string* SCNameResult::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCNameResult.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCNameResult::unsafe_arena_set_allocated_error(
    std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCNameResult.error)
}

// -------------------------------------------------------------------

// SCRoomsResult_RoomInfo

// required int32 roomId = 1;
inline bool SCRoomsResult_RoomInfo::_internal_has_roomid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SCRoomsResult_RoomInfo::has_roomid() const {
  return _internal_has_roomid();
}
inline void SCRoomsResult_RoomInfo::clear_roomid() {
  roomid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCRoomsResult_RoomInfo::_internal_roomid() const {
  return roomid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SCRoomsResult_RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.RoomInfo.roomId)
  return _internal_roomid();
}
inline void SCRoomsResult_RoomInfo::_internal_set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  roomid_ = value;
}
inline void SCRoomsResult_RoomInfo::set_roomid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.roomId)
}

// optional string title = 2;
inline bool SCRoomsResult_RoomInfo::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCRoomsResult_RoomInfo::has_title() const {
  return _internal_has_title();
}
inline void SCRoomsResult_RoomInfo::clear_title() {
  title_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCRoomsResult_RoomInfo::title() const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.RoomInfo.title)
  return _internal_title();
}
inline void SCRoomsResult_RoomInfo::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.title)
}
inline std::string* SCRoomsResult_RoomInfo::mutable_title() {
  // @@protoc_insertion_point(field_mutable:mju.SCRoomsResult.RoomInfo.title)
  return _internal_mutable_title();
}
inline const std::string& SCRoomsResult_RoomInfo::_internal_title() const {
  return title_.Get();
}
inline void SCRoomsResult_RoomInfo::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCRoomsResult_RoomInfo::set_title(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCRoomsResult.RoomInfo.title)
}
inline void SCRoomsResult_RoomInfo::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCRoomsResult.RoomInfo.title)
}
inline void SCRoomsResult_RoomInfo::set_title(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCRoomsResult.RoomInfo.title)
}
inline std::string* SCRoomsResult_RoomInfo::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCRoomsResult_RoomInfo::release_title() {
  // @@protoc_insertion_point(field_release:mju.SCRoomsResult.RoomInfo.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCRoomsResult_RoomInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCRoomsResult.RoomInfo.title)
}
inline std::string* SCRoomsResult_RoomInfo::unsafe_arena_release_title() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCRoomsResult.RoomInfo.title)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return title_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCRoomsResult_RoomInfo::unsafe_arena_set_allocated_title(
    std::string* title) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      title, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCRoomsResult.RoomInfo.title)
}

// repeated string members = 3;
inline int SCRoomsResult_RoomInfo::_internal_members_size() const {
  return members_.size();
}
inline int SCRoomsResult_RoomInfo::members_size() const {
  return _internal_members_size();
}
inline void SCRoomsResult_RoomInfo::clear_members() {
  members_.Clear();
}
inline std::string* SCRoomsResult_RoomInfo::add_members() {
  // @@protoc_insertion_point(field_add_mutable:mju.SCRoomsResult.RoomInfo.members)
  return _internal_add_members();
}
inline const std::string& SCRoomsResult_RoomInfo::_internal_members(int index) const {
  return members_.Get(index);
}
inline const std::string& SCRoomsResult_RoomInfo::members(int index) const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.RoomInfo.members)
  return _internal_members(index);
}
inline std::string* SCRoomsResult_RoomInfo::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:mju.SCRoomsResult.RoomInfo.members)
  return members_.Mutable(index);
}
inline void SCRoomsResult_RoomInfo::set_members(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.members)
  members_.Mutable(index)->assign(value);
}
inline void SCRoomsResult_RoomInfo::set_members(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:mju.SCRoomsResult.RoomInfo.members)
  members_.Mutable(index)->assign(std::move(value));
}
inline void SCRoomsResult_RoomInfo::set_members(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  members_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::set_members(int index, const char* value, size_t size) {
  members_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mju.SCRoomsResult.RoomInfo.members)
}
inline std::string* SCRoomsResult_RoomInfo::_internal_add_members() {
  return members_.Add();
}
inline void SCRoomsResult_RoomInfo::add_members(const std::string& value) {
  members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::add_members(std::string&& value) {
  members_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::add_members(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  members_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mju.SCRoomsResult.RoomInfo.members)
}
inline void SCRoomsResult_RoomInfo::add_members(const char* value, size_t size) {
  members_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mju.SCRoomsResult.RoomInfo.members)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SCRoomsResult_RoomInfo::members() const {
  // @@protoc_insertion_point(field_list:mju.SCRoomsResult.RoomInfo.members)
  return members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SCRoomsResult_RoomInfo::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:mju.SCRoomsResult.RoomInfo.members)
  return &members_;
}

// -------------------------------------------------------------------

// SCRoomsResult

// repeated .mju.SCRoomsResult.RoomInfo rooms = 1;
inline int SCRoomsResult::_internal_rooms_size() const {
  return rooms_.size();
}
inline int SCRoomsResult::rooms_size() const {
  return _internal_rooms_size();
}
inline void SCRoomsResult::clear_rooms() {
  rooms_.Clear();
}
inline ::mju::SCRoomsResult_RoomInfo* SCRoomsResult::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:mju.SCRoomsResult.rooms)
  return rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >*
SCRoomsResult::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:mju.SCRoomsResult.rooms)
  return &rooms_;
}
inline const ::mju::SCRoomsResult_RoomInfo& SCRoomsResult::_internal_rooms(int index) const {
  return rooms_.Get(index);
}
inline const ::mju::SCRoomsResult_RoomInfo& SCRoomsResult::rooms(int index) const {
  // @@protoc_insertion_point(field_get:mju.SCRoomsResult.rooms)
  return _internal_rooms(index);
}
inline ::mju::SCRoomsResult_RoomInfo* SCRoomsResult::_internal_add_rooms() {
  return rooms_.Add();
}
inline ::mju::SCRoomsResult_RoomInfo* SCRoomsResult::add_rooms() {
  // @@protoc_insertion_point(field_add:mju.SCRoomsResult.rooms)
  return _internal_add_rooms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mju::SCRoomsResult_RoomInfo >&
SCRoomsResult::rooms() const {
  // @@protoc_insertion_point(field_list:mju.SCRoomsResult.rooms)
  return rooms_;
}

// -------------------------------------------------------------------

// SCCreateRoomResult

// optional string error = 1;
inline bool SCCreateRoomResult::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCCreateRoomResult::has_error() const {
  return _internal_has_error();
}
inline void SCCreateRoomResult::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCCreateRoomResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCCreateRoomResult.error)
  return _internal_error();
}
inline void SCCreateRoomResult::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:mju.SCCreateRoomResult.error)
}
inline std::string* SCCreateRoomResult::mutable_error() {
  // @@protoc_insertion_point(field_mutable:mju.SCCreateRoomResult.error)
  return _internal_mutable_error();
}
inline const std::string& SCCreateRoomResult::_internal_error() const {
  return error_.Get();
}
inline void SCCreateRoomResult::_internal_set_error(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCCreateRoomResult::set_error(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCCreateRoomResult.error)
}
inline void SCCreateRoomResult::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCCreateRoomResult.error)
}
inline void SCCreateRoomResult::set_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCCreateRoomResult.error)
}
inline std::string* SCCreateRoomResult::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCCreateRoomResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCCreateRoomResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCCreateRoomResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCCreateRoomResult.error)
}
inline std::string* SCCreateRoomResult::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCCreateRoomResult.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCCreateRoomResult::unsafe_arena_set_allocated_error(
    std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCCreateRoomResult.error)
}

// -------------------------------------------------------------------

// SCJoinRoomResult

// optional string error = 1;
inline bool SCJoinRoomResult::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCJoinRoomResult::has_error() const {
  return _internal_has_error();
}
inline void SCJoinRoomResult::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCJoinRoomResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCJoinRoomResult.error)
  return _internal_error();
}
inline void SCJoinRoomResult::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:mju.SCJoinRoomResult.error)
}
inline std::string* SCJoinRoomResult::mutable_error() {
  // @@protoc_insertion_point(field_mutable:mju.SCJoinRoomResult.error)
  return _internal_mutable_error();
}
inline const std::string& SCJoinRoomResult::_internal_error() const {
  return error_.Get();
}
inline void SCJoinRoomResult::_internal_set_error(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCJoinRoomResult::set_error(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCJoinRoomResult.error)
}
inline void SCJoinRoomResult::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCJoinRoomResult.error)
}
inline void SCJoinRoomResult::set_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCJoinRoomResult.error)
}
inline std::string* SCJoinRoomResult::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCJoinRoomResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCJoinRoomResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCJoinRoomResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCJoinRoomResult.error)
}
inline std::string* SCJoinRoomResult::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCJoinRoomResult.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCJoinRoomResult::unsafe_arena_set_allocated_error(
    std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCJoinRoomResult.error)
}

// -------------------------------------------------------------------

// SCLeaveRoomResult

// optional string error = 1;
inline bool SCLeaveRoomResult::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCLeaveRoomResult::has_error() const {
  return _internal_has_error();
}
inline void SCLeaveRoomResult::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCLeaveRoomResult::error() const {
  // @@protoc_insertion_point(field_get:mju.SCLeaveRoomResult.error)
  return _internal_error();
}
inline void SCLeaveRoomResult::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:mju.SCLeaveRoomResult.error)
}
inline std::string* SCLeaveRoomResult::mutable_error() {
  // @@protoc_insertion_point(field_mutable:mju.SCLeaveRoomResult.error)
  return _internal_mutable_error();
}
inline const std::string& SCLeaveRoomResult::_internal_error() const {
  return error_.Get();
}
inline void SCLeaveRoomResult::_internal_set_error(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCLeaveRoomResult::set_error(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCLeaveRoomResult.error)
}
inline void SCLeaveRoomResult::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCLeaveRoomResult.error)
}
inline void SCLeaveRoomResult::set_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCLeaveRoomResult.error)
}
inline std::string* SCLeaveRoomResult::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCLeaveRoomResult::release_error() {
  // @@protoc_insertion_point(field_release:mju.SCLeaveRoomResult.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCLeaveRoomResult::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCLeaveRoomResult.error)
}
inline std::string* SCLeaveRoomResult::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCLeaveRoomResult.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCLeaveRoomResult::unsafe_arena_set_allocated_error(
    std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCLeaveRoomResult.error)
}

// -------------------------------------------------------------------

// SCChat

// required string member = 1;
inline bool SCChat::_internal_has_member() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCChat::has_member() const {
  return _internal_has_member();
}
inline void SCChat::clear_member() {
  member_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCChat::member() const {
  // @@protoc_insertion_point(field_get:mju.SCChat.member)
  return _internal_member();
}
inline void SCChat::set_member(const std::string& value) {
  _internal_set_member(value);
  // @@protoc_insertion_point(field_set:mju.SCChat.member)
}
inline std::string* SCChat::mutable_member() {
  // @@protoc_insertion_point(field_mutable:mju.SCChat.member)
  return _internal_mutable_member();
}
inline const std::string& SCChat::_internal_member() const {
  return member_.Get();
}
inline void SCChat::_internal_set_member(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCChat::set_member(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  member_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCChat.member)
}
inline void SCChat::set_member(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  member_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCChat.member)
}
inline void SCChat::set_member(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  member_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCChat.member)
}
inline std::string* SCChat::_internal_mutable_member() {
  _has_bits_[0] |= 0x00000001u;
  return member_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCChat::release_member() {
  // @@protoc_insertion_point(field_release:mju.SCChat.member)
  if (!_internal_has_member()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return member_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCChat::set_allocated_member(std::string* member) {
  if (member != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  member_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), member,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCChat.member)
}
inline std::string* SCChat::unsafe_arena_release_member() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCChat.member)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return member_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCChat::unsafe_arena_set_allocated_member(
    std::string* member) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (member != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  member_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      member, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCChat.member)
}

// required string text = 2;
inline bool SCChat::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SCChat::has_text() const {
  return _internal_has_text();
}
inline void SCChat::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SCChat::text() const {
  // @@protoc_insertion_point(field_get:mju.SCChat.text)
  return _internal_text();
}
inline void SCChat::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:mju.SCChat.text)
}
inline std::string* SCChat::mutable_text() {
  // @@protoc_insertion_point(field_mutable:mju.SCChat.text)
  return _internal_mutable_text();
}
inline const std::string& SCChat::_internal_text() const {
  return text_.Get();
}
inline void SCChat::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCChat::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCChat.text)
}
inline void SCChat::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCChat.text)
}
inline void SCChat::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCChat.text)
}
inline std::string* SCChat::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCChat::release_text() {
  // @@protoc_insertion_point(field_release:mju.SCChat.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCChat::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCChat.text)
}
inline std::string* SCChat::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCChat.text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCChat::unsafe_arena_set_allocated_text(
    std::string* text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCChat.text)
}

// -------------------------------------------------------------------

// SCSystemMessage

// required string text = 1;
inline bool SCSystemMessage::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SCSystemMessage::has_text() const {
  return _internal_has_text();
}
inline void SCSystemMessage::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SCSystemMessage::text() const {
  // @@protoc_insertion_point(field_get:mju.SCSystemMessage.text)
  return _internal_text();
}
inline void SCSystemMessage::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:mju.SCSystemMessage.text)
}
inline std::string* SCSystemMessage::mutable_text() {
  // @@protoc_insertion_point(field_mutable:mju.SCSystemMessage.text)
  return _internal_mutable_text();
}
inline const std::string& SCSystemMessage::_internal_text() const {
  return text_.Get();
}
inline void SCSystemMessage::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SCSystemMessage::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:mju.SCSystemMessage.text)
}
inline void SCSystemMessage::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:mju.SCSystemMessage.text)
}
inline void SCSystemMessage::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:mju.SCSystemMessage.text)
}
inline std::string* SCSystemMessage::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SCSystemMessage::release_text() {
  // @@protoc_insertion_point(field_release:mju.SCSystemMessage.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SCSystemMessage::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:mju.SCSystemMessage.text)
}
inline std::string* SCSystemMessage::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mju.SCSystemMessage.text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SCSystemMessage::unsafe_arena_set_allocated_text(
    std::string* text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mju.SCSystemMessage.text)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mju

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mju::Type_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mju::Type_MessageType>() {
  return ::mju::Type_MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
